use serde::Deserialize;

#[allow(dead_code)] 
#[derive(Clone, Deserialize)]
pub struct Offsets {
    pub timestamp: u64,

    #[serde(rename(deserialize = "signatures"))]
    pub sigs: Signatures,
    #[serde(rename(deserialize = "netvars"))]
    pub vars: Netvars,
}

#[allow(non_snake_case)] 
#[derive(Debug, Deserialize, Clone, Copy)]
pub struct Signatures {
    pub anim_overlays: u32,
    pub clientstate_choked_commands: u32,
    pub clientstate_delta_ticks: u32,
    pub clientstate_last_outgoing_command: u32,
    pub clientstate_net_channel: u32,
    pub convar_name_hash_table: u32,
    pub dwClientState: u32,
    pub dwClientState_GetLocalPlayer: u32,
    pub dwClientState_IsHLTV: u32,
    pub dwClientState_Map: u32,
    pub dwClientState_MapDirectory: u32,
    pub dwClientState_MaxPlayer: u32,
    pub dwClientState_PlayerInfo: u32,
    pub dwClientState_State: u32,
    pub dwClientState_ViewAngles: u32,
    pub dwEntityList: u32,
    pub dwForceAttack: u32,
    pub dwForceAttack2: u32,
    pub dwForceBackward: u32,
    pub dwForceForward: u32,
    pub dwForceJump: u32,
    pub dwForceLeft: u32,
    pub dwForceRight: u32,
    pub dwGameDir: u32,
    pub dwGameRulesProxy: u32,
    pub dwGetAllClasses: u32,
    pub dwGlobalVars: u32,
    pub dwGlowObjectManager: u32,
    pub dwInput: u32,
    pub dwInterfaceLinkList: u32,
    pub dwLocalPlayer: u32,
    pub dwMouseEnable: u32,
    pub dwMouseEnablePtr: u32,
    pub dwPlayerResource: u32,
    pub dwRadarBase: u32,
    pub dwSensitivity: u32,
    pub dwSensitivityPtr: u32,
    pub dwSetClanTag: u32,
    pub dwViewMatrix: u32,
    pub dwWeaponTable: u32,
    pub dwWeaponTableIndex: u32,
    pub dwYawPtr: u32,
    pub dwZoomSensitivityRatioPtr: u32,
    pub dwbSendPackets: u32,
    pub dwppDirect3DDevice9: u32,
    pub find_hud_element: u32,
    pub force_update_spectator_glow: u32,
    pub interface_engine_cvar: u32,
    pub is_c4_owner: u32,
    pub m_bDormant: u32,
    pub m_bIsLocalPlayer: u32,
    pub m_flSpawnTime: u32,
    pub m_pStudioHdr: u32,
    pub m_pitchClassPtr: u32,
    pub m_yawClassPtr: u32,
    pub model_ambient_min: u32,
    pub set_abs_angles: u32,
    pub set_abs_origin: u32,
}

#[allow(non_snake_case)]
#[derive(Debug, Deserialize, Clone, Copy)]
pub struct Netvars {
    pub cs_gamerules_data: u32,
    pub m_ArmorValue: u32,
    pub m_Collision: u32,
    pub m_CollisionGroup: u32,
    pub m_Local: u32,
    pub m_MoveType: u32,
    pub m_OriginalOwnerXuidHigh: u32,
    pub m_OriginalOwnerXuidLow: u32,
    pub m_SurvivalGameRuleDecisionTypes: u32,
    pub m_SurvivalRules: u32,
    pub m_aimPunchAngle: u32,
    pub m_aimPunchAngleVel: u32,
    pub m_angEyeAnglesX: u32,
    pub m_angEyeAnglesY: u32,
    pub m_bBombDefused: u32,
    pub m_bBombPlanted: u32,
    pub m_bBombTicking: u32,
    pub m_bFreezePeriod: u32,
    pub m_bGunGameImmunity: u32,
    pub m_bHasDefuser: u32,
    pub m_bHasHelmet: u32,
    pub m_bInReload: u32,
    pub m_bIsDefusing: u32,
    pub m_bIsQueuedMatchmaking: u32,
    pub m_bIsScoped: u32,
    pub m_bIsValveDS: u32,
    pub m_bSpotted: u32,
    pub m_bSpottedByMask: u32,
    pub m_bStartedArming: u32,
    pub m_bUseCustomAutoExposureMax: u32,
    pub m_bUseCustomAutoExposureMin: u32,
    pub m_bUseCustomBloomScale: u32,
    pub m_clrRender: u32,
    pub m_dwBoneMatrix: u32,
    pub m_fAccuracyPenalty: u32,
    pub m_fFlags: u32,
    pub m_flC4Blow: u32,
    pub m_flCustomAutoExposureMax: u32,
    pub m_flCustomAutoExposureMin: u32,
    pub m_flCustomBloomScale: u32,
    pub m_flDefuseCountDown: u32,
    pub m_flDefuseLength: u32,
    pub m_flFallbackWear: u32,
    pub m_flFlashDuration: u32,
    pub m_flFlashMaxAlpha: u32,
    pub m_flLastBoneSetupTime: u32,
    pub m_flLowerBodyYawTarget: u32,
    pub m_flNextAttack: u32,
    pub m_flNextPrimaryAttack: u32,
    pub m_flSimulationTime: u32,
    pub m_flTimerLength: u32,
    pub m_hActiveWeapon: u32,
    pub m_hBombDefuser: u32,
    pub m_hMyWeapons: u32,
    pub m_hObserverTarget: u32,
    pub m_hOwner: u32,
    pub m_hOwnerEntity: u32,
    pub m_hViewModel: u32,
    pub m_iAccountID: u32,
    pub m_iClip1: u32,
    pub m_iCompetitiveRanking: u32,
    pub m_iCompetitiveWins: u32,
    pub m_iCrosshairId: u32,
    pub m_iDefaultFOV: u32,
    pub m_iEntityQuality: u32,
    pub m_iFOV: u32,
    pub m_iFOVStart: u32,
    pub m_iGlowIndex: u32,
    pub m_iHealth: u32,
    pub m_iItemDefinitionIndex: u32,
    pub m_iItemIDHigh: u32,
    pub m_iMostRecentModelBoneCounter: u32,
    pub m_iObserverMode: u32,
    pub m_iShotsFired: u32,
    pub m_iState: u32,
    pub m_iTeamNum: u32,
    pub m_lifeState: u32,
    pub m_nBombSite: u32,
    pub m_nFallbackPaintKit: u32,
    pub m_nFallbackSeed: u32,
    pub m_nFallbackStatTrak: u32,
    pub m_nForceBone: u32,
    pub m_nModelIndex: u32,
    pub m_nTickBase: u32,
    pub m_nViewModelIndex: u32,
    pub m_rgflCoordinateFrame: u32,
    pub m_szCustomName: u32,
    pub m_szLastPlaceName: u32,
    pub m_thirdPersonViewAngles: u32,
    pub m_vecOrigin: u32,
    pub m_vecVelocity: u32,
    pub m_vecViewOffset: u32,
    pub m_viewPunchAngle: u32,
    pub m_zoomLevel: u32,
}

const OFFSET_STRING: &str = include_str!("../../../.build/offsets.toml");

impl Offsets {
    pub fn new() -> Self {
        let offsets: Offsets = toml::from_str(OFFSET_STRING)
            .expect("Failed to parse TOML");

        offsets
    }
}
